<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>latex备忘</title>
    <link href="/2023/05/d63b43ee1366.html"/>
    <url>/2023/05/d63b43ee1366.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>undefined</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交叉熵与对比损失</title>
    <link href="/2023/05/6c349570b12a.html"/>
    <url>/2023/05/6c349570b12a.html</url>
    
    <content type="html"><![CDATA[<p>已知交叉熵损失<br>$$ce&#x3D;-\sum^{n}<em>{i&#x3D;1}{y_ilog\hat{y_i}}$$<br>对比损失<br>$$loss</em>{con}&#x3D;-log{\frac{e^{sim(i,i)&#x2F;\tau}}{\sum_{j&#x3D;1}^{N}{e^{sim(i,j)&#x2F;\tau}}}}$$</p><p>$$loss_{con}&#x3D;-\frac{1}{m}\sum_{i&#x3D;1}^{m}{log{\frac{1}{1+e^{-sim(h_i^{-r},h_i^{orig})&#x2F;\tau}}}}-\frac{\lambda}{n}\sum_{j&#x3D;1}^{n}{log{\frac{1}{1+e^{-sim(h_i^{-r},h_i^{-e})&#x2F;\tau}}}}-\frac{1-\lambda}{n}\sum_{j&#x3D;1}^{n}{log{\frac{e^{-sim(h_i^{-r},h_i^{-e})&#x2F;\tau}}{1+e^{-sim(h_i^{-r},h_i^{-e})&#x2F;\tau}}}}$$$</p>]]></content>
    
    
    <categories>
      
      <category>undefined</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义loss</title>
    <link href="/2023/02/f79810992b84.html"/>
    <url>/2023/02/f79810992b84.html</url>
    
    <content type="html"><![CDATA[<p>按照神经网络的形式计算即可</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">My</span>_loss(nn.<span class="hljs-title class_">Module</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-variable language_">super</span>().__init__()<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, x, y</span>):<br>        <span class="hljs-keyword">return</span> torch.mean(torch.pow((x - y), <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>零碎笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自动混合精度</title>
    <link href="/2023/02/84a03cf4d2ad.html"/>
    <url>/2023/02/84a03cf4d2ad.html</url>
    
    <content type="html"><![CDATA[<p>fp16节省算力</p><p>参见pytorch官方说明，网上主流的方案不能用了</p>]]></content>
    
    
    <categories>
      
      <category>零碎笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>减假暂演示系统计划书</title>
    <link href="/2023/02/08590a235cd2.html"/>
    <url>/2023/02/08590a235cd2.html</url>
    
    <content type="html"><![CDATA[<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>供演示，则只需要简单的实现</p><ul><li>要素提取</li><li>时长预测</li></ul><h4 id="后续可追加"><a href="#后续可追加" class="headerlink" title="后续可追加"></a>后续可追加</h4><ul><li>识别类型</li><li>区间预测</li><li>要素依赖关系（如所判时长于犯罪类型必有依赖）</li><li>证据追踪</li><li>基于分类适配器，自适应增加新标签。</li><li>增量训练</li></ul>]]></content>
    
    
    <categories>
      
      <category>想法与计划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>招新考察点</title>
    <link href="/2023/02/e478c968147c.html"/>
    <url>/2023/02/e478c968147c.html</url>
    
    <content type="html"><![CDATA[<h3 id="关键要素"><a href="#关键要素" class="headerlink" title="关键要素"></a>关键要素</h3><ul><li>能力。过往的一些相关经验，对NLP的了解如何。</li><li>潜力。智力因素。</li><li>志向。方向是否吻合。</li><li>勤奋。略。</li></ul><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="基本资料"><a href="#基本资料" class="headerlink" title="基本资料"></a>基本资料</h4><h2 id="该部分看简历-本科院校、专业、省份。判断是哪个百分段。-报考院校、成绩。主要看成绩。-能力-对AI、NLP的了解程度。-为什么读研。很多人只是未准备好工作而读研，对科研认知不清晰（）。对这两点打一下感情牌。-过去做过什么东西。是否匹配。能体现什么素质。"><a href="#该部分看简历-本科院校、专业、省份。判断是哪个百分段。-报考院校、成绩。主要看成绩。-能力-对AI、NLP的了解程度。-为什么读研。很多人只是未准备好工作而读研，对科研认知不清晰（）。对这两点打一下感情牌。-过去做过什么东西。是否匹配。能体现什么素质。" class="headerlink" title="该部分看简历- 本科院校、专业、省份。判断是哪个百分段。- 报考院校、成绩。主要看成绩。#### 能力- 对AI、NLP的了解程度。- 为什么读研。很多人只是未准备好工作而读研，对科研认知不清晰（）。对这两点打一下感情牌。- 过去做过什么东西。是否匹配。能体现什么素质。"></a>该部分看简历<br>- 本科院校、专业、省份。判断是哪个百分段。<br>- 报考院校、成绩。主要看成绩。<br>#### 能力<br>- 对AI、NLP的了解程度。<br>- 为什么读研。很多人只是未准备好工作而读研，对科研认知不清晰（）。对这两点打一下感情牌。<br>- 过去做过什么东西。是否匹配。能体现什么素质。</h2><h4 id="潜力"><a href="#潜力" class="headerlink" title="潜力"></a>潜力</h4><ul><li>自评现在的优势，或自评将来的优势。</li><li>智力考察</li></ul><h4 id="勤奋度"><a href="#勤奋度" class="headerlink" title="勤奋度"></a>勤奋度</h4><ul><li>注意此点考察时，需要让其放松，以免给出违心答案</li></ul><h3 id="具体安排"><a href="#具体安排" class="headerlink" title="具体安排"></a>具体安排</h3><ol><li>看简历。面试前，筛掉显然不合适的。</li><li>先让其放松。先问对NLP的了解如何，顺带说不了解也无妨，课题室大半进组之前也毫无基础，其至少应当在前几天了解一些。再问读研的目的，以观其对未来规划是否明确。</li><li>问项目。看是否相关，不相关看能体现什么能力。（估计这部分较少）</li><li>英语能力。翻译两个句子。</li><li>考智力。智力题。</li></ol>]]></content>
    
    
    <categories>
      
      <category>undefined</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DP</title>
    <link href="/2023/02/435bc725b6cb.html"/>
    <url>/2023/02/435bc725b6cb.html</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>动态规划适用于<strong>重叠子问题</strong>的问题，动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，<strong>问题能够分解成子问题来解决。</strong><br>动态规划的关键在于找出<strong>状态转移方程</strong>。</p><h3 id="LeetCode-70-走楼梯"><a href="#LeetCode-70-走楼梯" class="headerlink" title="LeetCode 70 走楼梯"></a>LeetCode 70 走楼梯</h3><h4 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>每次可以走1或2步，记dp[i]为到第i个台阶的所有走法。那么显然可以在第i-1个台阶走一步到第i个台阶，也可以在第i-2个台阶走两步到第i个台阶。于是有递推式<code>dp[i] = dp[i-1] + dp[i-2]</code><br>n &#x3D; 0时，无意义，但是作为递推式中的可能存在，可以设为1，也可以不管，i从3起记。<br>n &#x3D; 1时，1种走法。<br>n &#x3D; 2时，2种走法。<br>于是代码可写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [<span class="hljs-number">1</span>] * (n + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 注意这种操作只能用于一维，用在二维上会导致各行同时变化</span><br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 注意范围，最终要落到dp[n]</span><br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><p>需要考虑到，dp[i]仅依赖于dp[i-1]和dp[i-2]，所以不必存储所有结果，可改写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        pre1 = <span class="hljs-number">1</span><br>        pre2 = <span class="hljs-number">1</span><br>        cur = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># n = 0 没有意义</span><br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            cur = pre1 + pre2<br>            pre2 = pre1<br>            pre1 = cur<br>        <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><h3 id="Leetcode-198-打家劫舍"><a href="#Leetcode-198-打家劫舍" class="headerlink" title="Leetcode 198 打家劫舍"></a>Leetcode 198 打家劫舍</h3><h4 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>设i间房最多偷dp[i]，对于每间房，可以选择偷或不偷。如果偷第i间，那么最多能偷dp[i-2]+m[i]；如果不偷，那么最多能偷dp[i-1]的钱。<br>所以得到状态转移方程<code>dp[i] = max(dp[i-1], dp[i-2] + m[i])</code><br>于是易得代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)]<br></code></pre></td></tr></table></figure><p>同样，dp[i]只依赖于dp[i-1]和dp[i-2]，可改写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        pre1 = nums[<span class="hljs-number">0</span>]<br>        pre2 = <span class="hljs-number">0</span><br>        cur = pre1<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            cur = <span class="hljs-built_in">max</span>(pre1, pre2 + nums[i])<br>            pre2 = pre1<br>            pre1 = cur<br>        <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><h3 id="Leetcode-413-等差数列划分"><a href="#Leetcode-413-等差数列划分" class="headerlink" title="Leetcode 413 等差数列划分"></a>Leetcode 413 等差数列划分</h3><h4 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h4><p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。<br>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。</p><p>子数组 是数组中的一个连续序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,4]<br>输出：3<br>解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。<br>示例 2：</p><p>输入：nums &#x3D; [1]<br>输出：0<br> <br>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>因为要求是<strong>连续</strong>等差数列，所以如果nums[i-3], nums[i-2], nums[i-1]是等差的，如果nums[i]与前面构成了等差，那么如果连续地到第i-1个位置能构成x个连续等差数列，第i个位置就能构成2x+1个，其中x个是未加上nums[i]的，x个是整体右移一位，1是到nums[i]的整个连续等差数列。<br>需要注意：如果nums[i]与前面不能构成等差呢？<strong>可能存在多个片段，所以不能直接存储到当前位置的所有可能。</strong><br>可以对每个位置，存储<strong>因当前位置，额外带来的可能。</strong><br>对位置i，如果<code>nums[i] - nums[i-1] == nums[i-1] - nums[i-2]</code>，那么这里形成了一个连续等差数列，对于等差数列，每加一位长度，<strong>每个长度的子集都会加一</strong>，并且多一个全集，如<br>三连等差，l3 +&#x3D; 1, 0-&gt; 1，增数1<br>四连等差，l3 +&#x3D; 1, 1 -&gt; 2; l4 +&#x3D; 1, 0 -&gt; 1，增数2<br>五连等差，l3 +&#x3D; 1, 2 -&gt; 3; l4 +&#x3D; 1, 1 -&gt; 2; l5 +&#x3D; 1, 0 -&gt; 1，增数3<br>也就是<code>dp[i] = dp[i-1] + 1</code>，只存储<strong>增数</strong>，最后对所有位置的增数求和，即所有可能。<br>代码很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numberOfArithmeticSlices</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            <span class="hljs-keyword">if</span> nums[i] - nums[i - <span class="hljs-number">1</span>] == nums[i - <span class="hljs-number">1</span>] - nums[i - <span class="hljs-number">2</span>]:<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>  <span class="hljs-comment"># 注意理解</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(dp)<br></code></pre></td></tr></table></figure><h3 id="Leetcode-64-最小路径和"><a href="#Leetcode-64-最小路径和" class="headerlink" title="Leetcode 64 最小路径和"></a>Leetcode 64 最小路径和</h3><h4 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h4><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><p><img src="/../../images/Pasted%20image%2020230304153708.png"><br>输入：&#96;grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p><p>输入：&#96;grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12</p><p>提示：<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>或许可以用深度优先搜索，一旦所尝试路径大于已找到的路径，则剪枝<br>可以存储到达每个位置的最小路径<br><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] 加上边界处理， 最后取</code>dp[m][n]&#96;即可<br>代码可写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathSum</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 式子 dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        line = [<span class="hljs-number">0</span>] * n<br>        dp = [line.copy() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]  <span class="hljs-comment"># 注意不能用line乘哦</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> i == <span class="hljs-number">0</span>:<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + grid[i][j]<br>                <span class="hljs-keyword">elif</span> j == <span class="hljs-number">0</span>:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + grid[i][j]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j]<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新学期研学计划</title>
    <link href="/2023/02/af93c37a17dd.html"/>
    <url>/2023/02/af93c37a17dd.html</url>
    
    <content type="html"><![CDATA[<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>过去所做的计划其实只是目标，这导致一个问题，不关乎详细或粗略，而是没有做到用<strong>计划</strong>促成<strong>目标</strong>。<br>以及做事不够专注，无法投入到手头的事情之中，是一个个人长存的问题。<br>对此需要明确自己当下、眼前要做的事情，需要更多地投入和效率。</p><p>关于横向，可以作为一试，正在研究的课题和减假暂目前看来可能可以结合，且由于领域特色正好可以避开和ChatGPT的竞争。（但是在用ChatGPT进行测试时，发现ChatGPT在找证据和给出解释时表现其实不差，只是由于问题类型原因，ChatGPT往往并不会真的给出答案）<br>    但在减假暂上，如果抛开知识图谱，只依靠文书进行预测。因为文书会有一定相关描述，所以对减刑时长进行大致的预测显然是可行的，之前放在BDCI上的赛题结果也说明了这一点。但是真正的实用问题是：<strong>用做监督，判断处理是否合理</strong>。其实存在两个问题：<strong>1. 文书中的信息必然是忠于文书判决的，所以不支持文书判决的内容，可能并不会呈现在文书中，导致缺乏负例。2. 文书中的信息量可能不足</strong>。那么即便预测的准确度能够提升，终究是有限制的，如何反馈成”<strong>这个判决符合&#x2F;不符合规定</strong>“，较难说通。</p><p>其实目前看来，研究方向也逐渐聚焦，目前的研究范围，以往走偏的路上耗费的精力也并非白费，但广度和深度都并不足够，本质上是源于以往效率较低。</p><p>论文相关：一直是想出论文的，但是对于论文的idea，如何才能实现突破，到达何种程度可以写出一篇论文。目前对课题进行了一些验证实验，虽然表现上是符合预期的，但其实都是些不经实验也能推测出的简单假设，不足以产出论文成果。</p><p>竞赛相关：前段时间，通过对BDCI赛题的审查和与俊鑫等人的交流，意识到了自己以往在竞赛上的误区。</p><p>其他，如专利软著等等，对之了解不足。</p><p>待人接物，向来是短板。</p><p>总结，主观上需要多一些勤奋和效率，客观上需要聚焦研究方向，深入研究目标。另需积极入世</p><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><ol><li>课题与横向结合，我应当是乐于接受的，但目前减假暂的项目，需要继续探究，如果只依靠文书内容，进一步的可行性如何。</li><li>论文上，计划再过一两个月，不论届时的方案实际效果如何，都以之为中心，按照论文标准尝试撰写一部分内容。</li><li>其他：竞赛，上半年不打算把精力放在这上面。专利软著等，这部分不是很懂，多加了解，短期仍不打算作为重点。</li></ol><p>总体上上半学期，计划将主要精力放在研究课题，以及可能涉及的横向上面。</p><p>克服惰性，提高效率，明确目标。</p>]]></content>
    
    
    <categories>
      
      <category>想法与计划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搜索-回溯法</title>
    <link href="/2023/02/462e40133c18.html"/>
    <url>/2023/02/462e40133c18.html</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状<br>态的深度优先搜索。通常来说，<strong>排列、组合、选择</strong>类问题使用回溯法比较方便。<br>顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及<br>其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态<br><strong>还原</strong>。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存<br>状态。在具体的写法上，它与普通的深度优先搜索一样，都有 [修改当前节点状态]→[递归子节<br>点] 的步骤，只是多了回溯的步骤，变成了 [修改当前节点状态]→[递归子节点]→[回改当前节点<br>状态]。<br>两个小诀窍，一是按引用传状态，二是所有的状态修改在递归完成后回改。<br>回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标<br>记，比如矩阵里搜字符串。</p><h3 id="Leetcode-46-全排列"><a href="#Leetcode-46-全排列" class="headerlink" title="Leetcode 46 全排列"></a>Leetcode 46 全排列</h3><h4 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h4><p>给定一个<strong>不含重复数字</strong>的数组 nums ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p><p>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p><p>输入：nums &#x3D; [1]<br>输出：[[1]] </p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 6</li><li>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10</li><li>nums 中的所有整数 互不相同</li></ul><h4 id="1-暴力中的暴力，随机解法"><a href="#1-暴力中的暴力，随机解法" class="headerlink" title="1. 暴力中的暴力，随机解法"></a>1. 暴力中的暴力，随机解法</h4><p>全排列可能共n!个，则直接随机排序，直到有n!个不重复答案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 你就说对不对吧</span><br>    check = math.factorial(<span class="hljs-built_in">len</span>(nums)) <br>    res = [] <br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(res) != check: <br>        random.shuffle(nums) <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>(nums) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res: <br>            res.append(<span class="hljs-built_in">str</span>(nums)) <br>    <br>    <span class="hljs-keyword">return</span> [json.loads(r) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> res]<br></code></pre></td></tr></table></figure><h4 id="2-直接递归"><a href="#2-直接递归" class="headerlink" title="2. 直接递归"></a>2. 直接递归</h4><p>要求得到的是全部的全排列，那么就依次去掉每一个数，求少一位数的全排列，再分别加上当前去掉的每一个数。只有一个数时，全排列就只有一种。<br>换种理解方式：</p><ul><li>一个数，全排列就一种</li><li>两个数，在已确定的一个数的基础上，有两个位置可以插，1*2</li><li>三个数，在已确定的两个数的基础上，有三个位置可以插，1*2*3</li><li>…</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]]:<br>        ans=[]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">1</span>:  <span class="hljs-comment"># 只有一个数，全排列就这一种</span><br>            <span class="hljs-keyword">return</span> [nums]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> self.permute(nums[<span class="hljs-number">0</span>:i]+nums[i+<span class="hljs-number">1</span>:]):  <span class="hljs-comment"># 这里是除去一个数后的全排列</span><br>                ans.append([nums[i]] + j)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="3-回溯1"><a href="#3-回溯1" class="headerlink" title="3. 回溯1"></a>3. 回溯1</h4><p>这种方法回溯体现的不是很明显，和2的递归法相类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:  <span class="hljs-comment"># 问题来了，不合适就回溯，体现在哪里？</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">nums, tmp</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:  <span class="hljs-comment"># nums空了，意味着tmp已经存储了一个排列</span><br>                res.append(tmp)<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):  <span class="hljs-comment"># nums还没空，对每个num，分别加到tmp后边，除该数之外的，再递归，直到nums为空，意味着确定了一个数</span><br>                backtrack(nums[:i] + nums[i+<span class="hljs-number">1</span>:], tmp + [nums[i]])<br>        backtrack(nums, [])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="4-回溯2"><a href="#4-回溯2" class="headerlink" title="4. 回溯2"></a>4. 回溯2</h4><p>这种方式能很好地体现回溯。<br>对于第i个数，向后(包括i自身，从而代表本来的顺序)进行一次交换，然后第i+1个数再向后进行一次交换，从而有n!种交换方式，就对应n!个结果。（但是为什么？）<br>向后交换，level代表交换的进度，<code>level == len(nums) - 1</code>时，意味着一个排列已经被找出，接下来开始逐个回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 主函数</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>, ans);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 辅函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> level, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (level == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>ans.<span class="hljs-built_in">push_back</span>(nums);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = level; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-built_in">swap</span>(nums[i], nums[level]); <span class="hljs-comment">// 修改当前节点状态</span><br><span class="hljs-built_in">backtracking</span>(nums, level+<span class="hljs-number">1</span>, ans); <span class="hljs-comment">// 递归子节点</span><br><span class="hljs-built_in">swap</span>(nums[i], nums[level]); <span class="hljs-comment">// 回改当前节点状态</span><br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>python版本有一点需要注意，res.append(nums)要用copy，因为python传值都是引用传值，最后nums会被改回，res也就变了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], level</span>):<br>            <span class="hljs-keyword">if</span> level == <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># print(nums)</span><br>                res.append(nums.copy())  <span class="hljs-comment"># 注意</span><br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(level, <span class="hljs-built_in">len</span>(nums)):<br>                nums[i], nums[level] = nums[level], nums[i]<br>                <span class="hljs-comment"># print(nums)</span><br>                backtrack(nums, level + <span class="hljs-number">1</span>)<br>                nums[i], nums[level] = nums[level], nums[i]<br>        backtrack(nums, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="Leetcode-77-组合"><a href="#Leetcode-77-组合" class="headerlink" title="Leetcode 77 组合"></a>Leetcode 77 组合</h3><h4 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h4><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><p>示例 1：</p><p>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br>示例 2：</p><p>输入：n &#x3D; 1, k &#x3D; 1<br>输出：[[1]] </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 20<br>1 &lt;&#x3D; k &lt;&#x3D; n</p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>求组合数，找k个数，以k作为指标，判断是否找到了足够的组合。<br>与上一个全排列相对应，全排列的思路是和后边交换位置，从而有顺序，而组合不要求顺序，就和后面的组合，组合后，再改回temp。其实这样相当于认为所有的组合都是不行的，搜索所有组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        temp = []<br>        <span class="hljs-comment"># 递归时应用k做指标</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">begin:<span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span>, temp: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>            <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 这时应当返回已确定的组合</span><br>                res.append(temp.copy())  <span class="hljs-comment"># 注意copy</span><br>                temp = []<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 对每个数进行一次选择，只往后看</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(begin, n + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 注意包括n</span><br>                temp.append(i)<br>                backtracking(i + <span class="hljs-number">1</span>, n, k - <span class="hljs-number">1</span>, temp)<br>                temp.pop()<br><br>        backtracking(<span class="hljs-number">1</span>, n, k, temp)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="Leetcode-79-单词搜索"><a href="#Leetcode-79-单词搜索" class="headerlink" title="Leetcode 79 单词搜索"></a>Leetcode 79 单词搜索</h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p> </p><p>示例 1：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true<br>示例 2：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “SEE”<br>输出：true<br>示例 3：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCB”<br>输出：false </p><p>提示：</p><p>m &#x3D;&#x3D; board.length<br>n &#x3D; board[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 6<br>1 &lt;&#x3D; word.length &lt;&#x3D; 15<br>board 和 word 仅由大小写英文字母组成</p><h4 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS+回溯"></a>DFS+回溯</h4><p>这算个正经的回溯。<br>首先，对于图中每个字母，都作为开始点，若匹配，则开始深度递归，状态矩阵用于记录是否访问过，若发现不能匹配，则回溯一部，并将状态位回复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 定义个状态矩阵</span><br>        status = []<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> board:<br>            temp = []<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> line:<br>                temp.append(<span class="hljs-number">1</span>)<br>            status.append(temp)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word_part, x, y</span>):<br>            <span class="hljs-comment"># 判断越界</span><br>            <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> y &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> x &gt;= <span class="hljs-built_in">len</span>(board) <span class="hljs-keyword">or</span> y &gt;= <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 判断是否已用</span><br>            <span class="hljs-keyword">if</span> status[x][y] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> board[x][y] + word_part == word:<br>                <span class="hljs-comment"># 找到了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> board[x][y] == word[-<span class="hljs-number">1</span> -<span class="hljs-built_in">len</span>(word_part)]:  <span class="hljs-comment"># 找到第一个后开始四向试探</span><br>                status[x][y] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">if</span> backtracking(board, board[x][y] + word_part, x + <span class="hljs-number">1</span>, y):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> backtracking(board, board[x][y] + word_part, x, y + <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> backtracking(board, board[x][y] + word_part, x - <span class="hljs-number">1</span>, y):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> backtracking(board, board[x][y] + word_part, x, y - <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                status[x][y] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">for</span> ix <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board)):<br>            <span class="hljs-keyword">for</span> iy <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> backtracking(board, <span class="hljs-string">&#x27;&#x27;</span>, ix, iy):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>强化学习篇</title>
    <link href="/2023/02/02618ddf2fb9.html"/>
    <url>/2023/02/02618ddf2fb9.html</url>
    
    <content type="html"><![CDATA[<h3 id="强化学习是什么？"><a href="#强化学习是什么？" class="headerlink" title="强化学习是什么？"></a>强化学习是什么？</h3><p>强化学习（reinforcement learning）是一类算法, 是让计算机实现从一开始什么都不懂, 脑袋里没有一点想法, 通过不断地尝试, 从错误中学习, 最后找到规律, 学会了达到目的的方法。<br>虚拟老师，不教怎么做，只给行为打分。<br>通过一次次在环境中的尝试, 获取这些数据和标签, 然后再学习通过哪些数据能够对应哪些标签, 通过学习到的这些规律, 尽可能地选择带来高分的行为。</p>]]></content>
    
    
    <categories>
      
      <category>零碎笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集束搜索和贪心搜索</title>
    <link href="/2023/02/e48d31209910.html"/>
    <url>/2023/02/e48d31209910.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>零碎笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pipeline</title>
    <link href="/2023/02/a4b942f9ec77.html"/>
    <url>/2023/02/a4b942f9ec77.html</url>
    
    <content type="html"><![CDATA[<ul><li>pipeline是流水线式，输入A–&gt;输出A，输出A–&gt; 输出B</li><li>端到端就是一步式</li></ul>]]></content>
    
    
    <categories>
      
      <category>零碎笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>失去的三年</title>
    <link href="/2023/01/4f52cf88ae40.html"/>
    <url>/2023/01/4f52cf88ae40.html</url>
    
    <content type="html"><![CDATA[<p>2020年初夏，我和室友去买纸箱，当时下着非常大的雨。<br>拍毕业照时，我忘了跟院长合影被拽了回去，后来同学们合照时，我又忘了摘下口罩。我总是迷迷糊糊的，我当时想，怎么弥补呢？事实上也不需要什么弥补吧。<br>我不舍得用大面积的胶带，便只是封了几遍封口，我也不想要太大的行囊，床褥被子牙刷牙缸洗发水等等等等都留在了那里。<br>我曾经怕把文件弄丢了，便都把它们夹在高数课本里。<br>我没用到那些文件，也没再用到高数课本。<br>后来我离开宿舍，我知道这扇门再也不会为我而开。<br>路过食堂，我知道清真窗口以后会少一个不清真的常客。<br>路过注销水卡的队伍，我的三十三块永远留在了里面。<br>走出校门，那是2020年，我的绿卡从此作废了。<br>坐上了回家的大巴车，我家离学校很近，很快就到家了。<br>只是下次回去，是什么时候呢？已经不能用“回”了。<br>我进了家门，突然感到一阵迷茫。<br>父母责怪我包装不用心，路上的雨弄破了我的纸箱。<br>我根本不在意，我问自己：<br>四年已经结束了吗？<br>将来的路在何方呢？<br>带着这份迷茫，我到家后，便有了新的想法。<br>当我筹划好之后，告诉父母，父母严词不许。<br>我才21岁。<br>有时候我不懂，我的父母18岁便承担起了一切，我21岁却还是他们的孩子，我又无法否认。<br>那是2020，我出不去。<br>于是，在一间小房间中，我独自度过了一年半的时间。<br>我先是高估了自己的心理素质，后是低估了自己的能力。<br>如今看，我放弃的太早，但是我早已心如死灰，又能如何呢？<br>我是被抬上战场的。<br>我未抱任何希望，我决定应付完父母，就出去流浪。<br>命运总是要把我按死在一条路上。<br>就在我22岁生日那天，我以为我得到了一个意外的好消息，我终于感觉人生可以继续。<br>就在吃过了丰盛的晚饭后，这好消息又没了。<br>大概我最后一次做出正确选择是2016年的夏天。<br>我曾说，我是好运的去心邻域，带给人好运，带给自己霉运。<br>我其实自己都很担心，我是一个本就不经世事、不善交际的人，与世隔绝这么久，怎么去生活，怎么跟人交流？事实上这倒成了最简单的事情。<br>有那么一段时间，我也感觉我可以新生，但很快，这热情又消逝了。<br>我翻动着曾经的留言，发现一切都在2019年11月凝固了。<br>在这失去的三年里，我的记忆却停留在了当初，给我留下这些记忆的却已经物是人非了。</p>]]></content>
    
    
    <categories>
      
      <category>书心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一般流程</title>
    <link href="/2023/01/e04accf0aceb.html"/>
    <url>/2023/01/e04accf0aceb.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b646fda360bd45af3563c1be89b6fb080262097cd547fd2a4cdc6364a8703569">10d79030e8222445804370796b90fca18cba4bc9b12f9975721e09c9ac98f19183a7c38fa9254babf0f1b3930d09467e30da942afcb95fa572284454a205cb7be6e153a6540baa88aa1084c0f0ef1d4623123ae6308354303a4ba675500978a481d8aa9228377d634e5a6896683628bf270a99f0bdb0d6c55462ca69bf3b254eb538beae8f675cd257efe66dd581e52f63a6c0490becf5d00e780fd7bdba9ecb1fcdd64c453f58dc5a10a3574a53ada314c7fcaec1ec92736b620c20cc787ea7c8f00495e673bc2401510d9d9a5c3c05f6661c61d6cd6a3fb79a2bdf79db88a48f972c1b1600a02681a0036c12e4278d89f1c4583cce6722033d595082fcf32e6e78f33eaf3b6cca91677648f8a31db8b3580c09a298c803499450176b4e0dc9dc30dfa0998736685a6b725ded1b4fe24f420df3937fc734ed36af9a891bfcf5b2d8772ed672c19d43a86fc825ff87ba6be63fb6b20fa95702de6be9e466f47e168c574513e7b631c0e6794041368180112f88e15f3498abf6c7daa797e9f46c330e22bcde73aa0b9c03dedb63af7e0f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>关于我</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搜索-DFS</title>
    <link href="/2023/01/bdd6de1f587c.html"/>
    <url>/2023/01/bdd6de1f587c.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>爱恶</title>
    <link href="/2023/01/1336efb496df.html"/>
    <url>/2023/01/1336efb496df.html</url>
    
    <content type="html"><![CDATA[<h3 id="一些价值观"><a href="#一些价值观" class="headerlink" title="一些价值观"></a>一些价值观</h3><h3 id="喜欢"><a href="#喜欢" class="headerlink" title="喜欢"></a>喜欢</h3><hr><h3 id="嫌恶"><a href="#嫌恶" class="headerlink" title="嫌恶"></a>嫌恶</h3><p>我嫌恶的东西。</p><h4 id="卑微"><a href="#卑微" class="headerlink" title="卑微"></a>卑微</h4><p>尊重自己的人才值得被尊重。<br>我察觉到自己有一种奇怪的倾向，对于“可怜”的东西会很嫌恶。这种“可怜”指能解放自己却非要做奴隶。<br>舔狗就是一种具体的例子吧。</p><h4 id="蛮横"><a href="#蛮横" class="headerlink" title="蛮横"></a>蛮横</h4><hr><h3 id="红线"><a href="#红线" class="headerlink" title="红线"></a>红线</h3><p>触此没有商量余地。<br>恶劣的欺瞒。这种人理论上甚至不会在我的友好名单中，没有任何商量余地。<br>我是一个很难被骗的人，但是对于无害的，当然无所谓。</p>]]></content>
    
    
    <categories>
      
      <category>关于我</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo实现文档加密</title>
    <link href="/2023/01/be0f6063f14c.html"/>
    <url>/2023/01/be0f6063f14c.html</url>
    
    <content type="html"><![CDATA[<h3 id="Hexo-Obsidian-Git"><a href="#Hexo-Obsidian-Git" class="headerlink" title="Hexo+Obsidian+Git"></a>Hexo+Obsidian+Git</h3><p>实现多端同步，实质上也就不同PC端，安卓obsidian会卡死。</p><h3 id="文档加密"><a href="#文档加密" class="headerlink" title="文档加密"></a>文档加密</h3><p>安装<code>hexo-blog-encrypt</code>并添加<code>password</code>字段</p><h3 id="不在首页展示"><a href="#不在首页展示" class="headerlink" title="不在首页展示"></a>不在首页展示</h3><ol><li><del>一般说是添加<code>notshow</code>字段，但这个对<code>fluid</code>主题无效</del></li><li><code>fluid</code>主题得用<code>hide</code></li></ol><h3 id="很坑的站内链接"><a href="#很坑的站内链接" class="headerlink" title="很坑的站内链接"></a>很坑的站内链接</h3><p>应该用<code>&#123;% post_link <不要目录直接文档名> '显示文字' %&#125;</code>，和别处说的不一样，不懂</p>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>续写2020计划</title>
    <link href="/2023/01/353a43af78c5.html"/>
    <url>/2023/01/353a43af78c5.html</url>
    
    <content type="html"><![CDATA[<h3 id="将2023分为四段"><a href="#将2023分为四段" class="headerlink" title="将2023分为四段"></a>将2023分为四段</h3><p>每个月是一个季节</p><h4 id="2020年春"><a href="#2020年春" class="headerlink" title="2020年春"></a>2020年春</h4><p>从2019结束后到如今，算是2020年春天过去了。</p><h4 id="2020年夏"><a href="#2020年夏" class="headerlink" title="2020年夏"></a>2020年夏</h4><p>2023年2月。</p>]]></content>
    
    
    <categories>
      
      <category>想法与计划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的使用说明书</title>
    <link href="/2023/01/42503dcd5a93.html"/>
    <url>/2023/01/42503dcd5a93.html</url>
    
    <content type="html"><![CDATA[<h3 id="个人资料"><a href="#个人资料" class="headerlink" title="个人资料"></a>个人资料</h3><ul><li>身高：180cm，无虚报。</li><li>体重：73kg，20230127。</li><li>地址。山东</li><li>生日。按农历</li><li>信仰。表现为无神论的不可知论者。</li><li>不烟。严格不抽烟。</li><li>不酒。除非低度甜酒。</li></ul><h3 id="意向"><a href="#意向" class="headerlink" title="意向"></a>意向</h3><ul><li>将来发展地区。江浙。所有赏工作的地方。</li><li>人生规划。赚够钱就退休。</li></ul><h3 id="社交媒体平台相关"><a href="#社交媒体平台相关" class="headerlink" title="社交媒体平台相关"></a>社交媒体平台相关</h3><ul><li>微信。常在</li><li>QQ。常在。</li><li>知乎。2017年开始不再刷知乎，只用作搜索引擎。</li><li>短视频平台。不看。</li><li>微博。不看。</li></ul><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><ul><li>不玩</li><li>少玩</li><li>喜欢玩</li></ul><h3 id="反感"><a href="#反感" class="headerlink" title="反感"></a>反感</h3><ul><li>卑微。不尊重自己的人不配得到尊重。</li><li>张扬。挫锐解纷，和光同尘。</li><li>丧气。人纵是踩着草鞋，也应仰望星空。</li></ul><h3 id="加密部分"><a href="#加密部分" class="headerlink" title="加密部分"></a>加密部分</h3><ul><li>需联系本人</li><li><a href="/2023/01/bafcd158cbc4.html" title="我的过去">私密</a></li></ul><h3 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h3><p>mammm</p><pre class="mermaid">graph TDstart((开始)) --> A[相识]A --> B{友好?}B --yes--> C{性别?}B --no--> 结束((结束))C --女--> D[发展好感]C --男--> 结束D --> F{好感?}F --yes--> M[继续发展]M --> G{暧昧?}F --no--> 结束G --yes--> H[深入了解]G --no--> 结束H --> I{观念吻合?}I --yes--> J[女朋友]I --no--> 结束</pre>]]></content>
    
    
    <categories>
      
      <category>关于我</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>贩卖死亡</title>
    <link href="/2023/01/425c66e15585.html"/>
    <url>/2023/01/425c66e15585.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>批评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客完善计划</title>
    <link href="/2023/01/968e461ab5d1.html"/>
    <url>/2023/01/968e461ab5d1.html</url>
    
    <content type="html"><![CDATA[<h2 id="这篇博客应该有什么东西"><a href="#这篇博客应该有什么东西" class="headerlink" title="这篇博客应该有什么东西"></a>这篇博客应该有什么东西</h2><h3 id="学习相关"><a href="#学习相关" class="headerlink" title="学习相关"></a>学习相关</h3><ol><li>论文笔记</li><li>对问题和bug的解决方案以及记录</li><li>leetcode代码题解</li></ol><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><ol><li>想法、灵感记录</li><li>对一些事情的评判</li><li>随笔</li><li>资源</li></ol><h3 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h3><ol><li>关于我的一些记录</li><li>一些需求</li></ol>]]></content>
    
    
    <categories>
      
      <category>想法与计划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于博客</title>
    <link href="/2023/01/25cf6d6bb3be.html"/>
    <url>/2023/01/25cf6d6bb3be.html</url>
    
    <content type="html"><![CDATA[<h2 id="提醒下这个博客我都做了什么"><a href="#提醒下这个博客我都做了什么" class="headerlink" title="提醒下这个博客我都做了什么"></a>提醒下这个博客我都做了什么</h2><p>都是主题fluid下配置的<br>看板娘用了live2d-widget和live2d_api，看板娘资源在后者里面，要记得更新<br>live2d_api得额外搭建，这里没起到作用。。。<br>skip_render忽略下live2d，以免耗费资源<br>fluid主题优先用博客目录下的_confg.fluid.yml<br>hexo的根目录是source</p>]]></content>
    
    
    <categories>
      
      <category>undefined</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>战争与和平</title>
    <link href="/2023/01/52cbe2190d15.html"/>
    <url>/2023/01/52cbe2190d15.html</url>
    
    <content type="html"><![CDATA[<h3 id="热爱和平和主战并不矛盾"><a href="#热爱和平和主战并不矛盾" class="headerlink" title="热爱和平和主战并不矛盾"></a>热爱和平和主战并不矛盾</h3><p>压迫下的和平不是和平，战争才能带来真正的和平。</p>]]></content>
    
    
    <categories>
      
      <category>评</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>健康</title>
    <link href="/2023/01/91e92fd98a75.html"/>
    <url>/2023/01/91e92fd98a75.html</url>
    
    <content type="html"><![CDATA[<h3 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h3><ul><li>有钱后买角膜接触镜</li><li>避免习惯性眯眼</li><li>浅色背景深色文字，适合一般人尤其是散光人群；弱视，强光敏感适合黑色背景；暗色不能用纯黑</li></ul>]]></content>
    
    
    <categories>
      
      <category>undefined</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown规范</title>
    <link href="/2023/01/0f06b066a991.html"/>
    <url>/2023/01/0f06b066a991.html</url>
    
    <content type="html"><![CDATA[<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul><li>一级标题，一般不用</li><li>二级标题，一般用在文档开头</li><li>三级标题，一般每个小节使用</li><li>四级标题，一般每个小节下的段落使用</li><li>五级标题，一般不用</li><li>六级标题，一般不用</li></ul>]]></content>
    
    
    <categories>
      
      <category>undefined</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法备忘</title>
    <link href="/2023/01/a348bc98db69.html"/>
    <url>/2023/01/a348bc98db69.html</url>
    
    <content type="html"><![CDATA[<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li>行内<br>使用 `code` 插入<code>code</code>这样的代码块</li><li>多行<br>使用```开始，并使用```结束，也可以用~，如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;helloworld&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>用<code>~~要删除的文字~~</code>表示如：<br><del>要删除的文字</del></p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>行内<code>$latex公式$</code>，独立一行<code>$$latex公式$$</code>，如$F &#x3D; ma$<br>和<br>$$E &#x3D; mc^2$$</p>]]></content>
    
    
    <categories>
      
      <category>undefined</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git小常识</title>
    <link href="/2023/01/2d62fc9c40e1.html"/>
    <url>/2023/01/2d62fc9c40e1.html</url>
    
    <content type="html"><![CDATA[<h3 id="git-换行符问题"><a href="#git-换行符问题" class="headerlink" title="git 换行符问题"></a>git 换行符问题</h3><p>Git: ‘LF will be replaced by CRLF the next time Git touches it<br>原因：Windows 使用 CRLF，Linux 和 git 使用 LF</p><ol><li>对于 Windows 系统（默认，推荐）<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 提交时转换为LF，检出时转换为CRLF</span><br>git config --<span class="hljs-keyword">global</span> core.autocrlf <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>或仅在 Windows 上开发操作时<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 提交检出均不转换</span><br>git config --<span class="hljs-keyword">global</span> core.autocrlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li>对于 Linux 系统<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提交时转换为LF，检出时不转换</span><br>git config --<span class="hljs-keyword">global</span> core.autocrlf <span class="hljs-built_in">input</span><br></code></pre></td></tr></table></figure>解决方案：<br>不管，或修改 .gitattributes</li></ol><h3 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h3><p>即 internationalization，i+18 个字符+n，自动多国语言。</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>顾名思义，git 忽略其中指定文件&#x2F;文件夹的改动</p><h3 id="gitkeep"><a href="#gitkeep" class="headerlink" title=".gitkeep"></a>.gitkeep</h3><p>只是为了使文件夹不再为空，从而不会被忽视，命名为约定俗成</p><h3 id="gitattribute"><a href="#gitattribute" class="headerlink" title=".gitattribute"></a>.gitattribute</h3><p>定义一些属性</p>]]></content>
    
    
    <categories>
      
      <category>undefined</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+Obsidian+git</title>
    <link href="/2023/01/ebc68c8fc218.html"/>
    <url>/2023/01/ebc68c8fc218.html</url>
    
    <content type="html"><![CDATA[<p>通过这种方式实现笔记同步及博客功能</p>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Transformer</title>
    <link href="/2023/01/c889ff09a7fe.html"/>
    <url>/2023/01/c889ff09a7fe.html</url>
    
    <content type="html"><![CDATA[<p>Transformer非常NB</p><p>888</p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/4c968712a1d1.html"/>
    <url>/2023/01/4c968712a1d1.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
