---
title: 搜索-回溯法
tags: []
categories:
  - LeetCode101
date: 2023-02-10 18:21:27
---
### 概念
回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状
态的深度优先搜索。通常来说，**排列、组合、选择**类问题使用回溯法比较方便。
顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及
其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态
**还原**。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存
状态。在具体的写法上，它与普通的深度优先搜索一样，都有 [修改当前节点状态]→[递归子节
点] 的步骤，只是多了回溯的步骤，变成了 [修改当前节点状态]→[递归子节点]→[回改当前节点
状态]。
两个小诀窍，一是按引用传状态，二是所有的状态修改在递归完成后回改。
回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标
记，比如矩阵里搜字符串。

### Leetcode 46
#### 题干
给定一个**不含重复数字**的数组 nums ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]
 

提示：

- 1 <= nums.length <= 6
- -10 <= nums[i] <= 10
- nums 中的所有整数 互不相同

#### 1. 暴力中的暴力，随机解法
全排列可能共n!个，则直接随机排序，直到有n!个不重复答案
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
    # 你就说对不对吧
    check = math.factorial(len(nums)) 
    res = [] 
    while len(res) != check: 
        random.shuffle(nums) 
        if str(nums) not in res: 
            res.append(str(nums)) 
    
    return [json.loads(r) for r in res]
```
#### 2. 直接递归
要求得到的是全部的全排列，那么就依次去掉每一个数，求少一位数的全排列，再分别加上当前去掉的每一个数。只有一个数时，全排列就只有一种。
换种理解方式：
- 一个数，全排列就一种
- 两个数，在已确定的一个数的基础上，有两个位置可以插，1\*2
- 三个数，在已确定的两个数的基础上，有三个位置可以插，1\*2\*3
- ...

```python
class Solution:
    def permute(self, nums: list[int]) -> list[list[int]]:
        ans=[]
        if len(nums)==1:  # 只有一个数，全排列就这一种
            return [nums]
        for i in range(len(nums)):
            for j in self.permute(nums[0:i]+nums[i+1:]):  # 这里是除去一个数后的全排列
                ans.append([nums[i]] + j)
        return ans
```

#### 3. 回溯1

这种方法回溯体现的不是很明显，和2的递归法相类似
```python
class Solution:  # 问题来了，不合适就回溯，体现在哪里？
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(nums, tmp):
            if not nums:  # nums空了，意味着tmp已经存储了一个排列
                res.append(tmp)
                return 
            for i in range(len(nums)):  # nums还没空，对每个num，分别加到tmp后边，除该数之外的，再递归，直到nums为空，意味着确定了一个数
                backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]])
        backtrack(nums, [])
        return res
```

#### 4. 回溯2

这种方式能很好地体现回溯。
对于第i个数，向后(包括i自身，从而代表本来的顺序)进行一次交换，然后第i+1个数再向后进行一次交换，从而有n!种交换方式，就对应n!个结果。（但是为什么？）
向后交换，level代表交换的进度，`level == len(nums) - 1`时，意味着一个排列已经被找出，接下来开始逐个回溯。

```cpp
class Solution {
	public:
    // 主函数
	vector<vector<int>> permute(vector<int>& nums) {
		vector<vector<int>> ans;
		backtracking(nums, 0, ans);
		return ans;
	}

	// 辅函数
	void backtracking(vector<int> &nums, int level, vector<vector<int>> &ans) {
		if (level == nums.size() - 1) {
			ans.push_back(nums);
			return;
		}
		for (int i = level; i < nums.size(); i++) {
			swap(nums[i], nums[level]); // 修改当前节点状态
			backtracking(nums, level+1, ans); // 递归子节点
			swap(nums[i], nums[level]); // 回改当前节点状态
		}
	}
};
```

python版本有一点需要注意，res.append(nums)要用copy，因为python传值都是引用传值，最后nums会被改回，res也就变了
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(nums: List[int], level):
            if level == len(nums) - 1:
                # print(nums)
                res.append(nums.copy())  # 注意
                return 
            for i in range(level, len(nums)):
                nums[i], nums[level] = nums[level], nums[i]
                # print(nums)
                backtrack(nums, level + 1)
                nums[i], nums[level] = nums[level], nums[i]
        backtrack(nums, 0)
        return res
```